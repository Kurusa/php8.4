<?php
/**
 * Property Hooks забезпечують можливість встановлення властивостей через хуки "get" і "set".
 * Це дозволяє динамічно контролювати доступ до властивостей, валідувати чи обчислювати значення.
 *
 * Властивості класу були частиною PHP, забезпечуючи стандартний механізм для інкапсуляції стану в класі.
 * Проте, динамічні властивості, які дозволяли додавати стан "на льоту", створювали низку проблем:
 * - Відсутність гарантій щодо типу або дійсності значення.
 * - Важкість у визначенні контрактів для таких властивостей.
 *
 * Раніше використовувалися такі підходи:
 * 1. Магічні методи:
 *    Методи __get, __set, __isset та __unset дозволяли взаємодіяти з невизначеними або непублічними властивостями.
 *    Проте вони мали значні недоліки, такі як відсутність явної декларації властивостей.
 * 2. Геттери та сеттери:
 *    Замість публічних властивостей використовувались методи для доступу до стану класу. Хоча цей підхід забезпечував валідацію,
 *    він збільшував обсяг коду.
 * 3. Readonly властивості:
 *    У PHP 8.1 додали можливість створення властивостей лише для читання, що вирішило багато проблем для об’єктів,
 *    стан яких не змінюється після створення.
 *
 * Property Hooks забезпечують новий рівень контролю над властивостями:
 * - Можливість динамічно виконувати логіку під час доступу або модифікації властивості.
 * - Підтримка віртуальних властивостей, значення яких обчислюються динамічно.
 * - Інкапсуляція логіки доступу та модифікації без необхідності в геттерах і сеттерах.
 */

// Приклад використання хуків для простих властивостей
class User
{
    public function __construct(private string $first, private string $last)
    {
    }

    public string $fullName {
        get => $this->first . ' ' . $this->last;
        set {
            [$this->first, $this->last] = explode(' ', $value, 2);
        }
    }
}

$user = new User('John', 'Doe');
echo "User full name: {$user->fullName}" . PHP_EOL;
$user->fullName = 'Jane Smith';
echo "New user full name: {$user->fullName}" . PHP_EOL;

// Хуки з валідацією даних
class Address
{
    public function __construct(
        private string $city {
            get => ucfirst($this->city);
            set {
                if (empty($value)) {
                    throw new InvalidArgumentException("City cannot be empty.");
                }
                $this->city = trim($value);
            }
        },
        private string $country
    )
    {
    }

    public string $fullAddress {
        get => "$this->city, $this->country";
        set {
            [$this->city, $this->country] = explode(', ', $value);
        }
    }
}

$address = new Address('kyiv', 'Ukraine');
echo "Address: {$address->fullAddress}" . PHP_EOL;
$address->fullAddress = 'Lviv, Ukraine';
echo "New address: {$address->fullAddress}" . PHP_EOL;

// Масиви: хуки не обробляють модифікації напряму
class ArrayExample
{
    public array $items {
        get => $this->items;
        set {
            if (!is_array($value)) {
                throw new InvalidArgumentException('Value must be an array.');
            }
            $this->items = $value;
        }
    }
}

$arrayExample = new ArrayExample();
$arrayExample->items = [1, 2, 3];
print_r($arrayExample->items); // [1, 2, 3]

// Наступне не спрацює, бо не викликається set-хук
// $arrayExample->items[] = 4; // Це не викликає set-хук і змінює масив напряму
$array = $arrayExample->items;
$array[] = 4;
print_r($array); // [1, 2, 3, 4]


/**
 * Особливості Property Hooks:
 *
 * 1. Асинхронність доступу: значення можна обчислювати під час доступу.
 * 2. Валідація: гарантує, що властивостям призначаються лише дійсні значення.
 * 3. Інкапсуляція логіки: логіка роботи з даними переноситься у властивості, що спрощує API класу.
 * 4. Підтримка віртуальних властивостей: обчислюються на основі інших полів без зберігання.
 * 5. Інтеграція з успадкуванням та інтерфейсами:
 *    - Успадковані класи можуть перевизначати хуки.
 *    - Інтерфейси можуть визначати контракти для властивостей з хуками.
 *
 * Обмеження
 * - Хуки не обробляють модифікації масивів напряму ($instance->array[] = value).
 * - Варто уникати складних взаємозалежностей між властивостями для збереження читабельності.
 */
